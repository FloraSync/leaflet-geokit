<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>@florasync/leaflet-geokit — Preact Bundled Dev</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- No Leaflet CDN - bundled with component -->

    <style>
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Helvetica,
          Arial,
          Noto Sans,
          "Apple Color Emoji",
          "Segoe UI Emoji";
        display: grid;
        grid-template-rows: auto auto 1fr;
      }
      header {
        padding: 10px 12px;
        border-bottom: 1px solid #ddd;
        background: #fafafa;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 12px;
      }
      .header-title {
        display: flex;
        align-items: baseline;
        gap: 6px;
      }
      .geocoder {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .geocoder input {
        padding: 6px 10px;
        border: 1px solid #c6c6c6;
        border-radius: 6px;
        font-size: 14px;
        min-width: 240px;
      }
      .geocode-status {
        font-size: 12px;
        color: #555;
      }
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
      .wrap {
        padding: 12px;
        height: 100%;
        display: grid;
        grid-template-columns: 1fr 360px;
        gap: 12px;
      }
      #map-container {
        height: 100%;
        width: 100%;
        border-radius: 8px;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.08) inset;
        overflow: hidden;
      }
      leaflet-geokit {
        display: block;
        height: 100%;
        width: 100%;
      }
      .panel {
        border: 1px solid #e5e5e5;
        border-radius: 8px;
        padding: 10px;
        background: #fff;
        overflow: auto;
      }
      .panel pre {
        white-space: pre-wrap;
        word-break: break-word;
        font-size: 12px;
        line-height: 1.4;
      }
      .row {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
        flex-wrap: wrap;
      }
      .row code {
        background: #f2f2f2;
        padding: 2px 6px;
        border-radius: 4px;
      }
      .btn {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        background: #0f62fe;
        color: #fff;
        border: none;
        border-radius: 6px;
        cursor: pointer;
      }
      .btn.secondary {
        background: #e0e0e0;
        color: #222;
      }
      .toast-container {
        position: fixed;
        top: 12px;
        right: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 9999;
        pointer-events: none;
      }
      .toast {
        pointer-events: auto;
        min-width: 240px;
        max-width: 420px;
        padding: 10px 12px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        background: #fff;
        border: 1px solid rgba(0, 0, 0, 0.08);
        font-size: 13px;
        color: #222;
        opacity: 0;
        transform: translateY(-4px);
        transition:
          opacity 0.18s ease,
          transform 0.18s ease;
      }
      .toast.show {
        opacity: 1;
        transform: translateY(0);
      }
      .toast.info {
        border-left: 4px solid #0f62fe;
      }
      .toast.success {
        border-left: 4px solid #24a148;
      }
      .toast.error {
        border-left: 4px solid #da1e28;
      }
      .harness-nav {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 8px 12px;
        background: #e8e8e8;
        border-bottom: 1px solid #ccc;
        font-size: 13px;
        align-items: center;
      }
      .harness-nav a {
        color: #0066cc;
        text-decoration: none;
        padding: 2px 8px;
        border-radius: 4px;
      }
      .harness-nav a:hover {
        background: rgba(0, 102, 204, 0.1);
      }
      .harness-nav a.active {
        font-weight: 600;
        color: #333;
        background: #fff;
        pointer-events: none;
        border: 1px solid #ccc;
      }
      .harness-nav .nav-divider {
        width: 1px;
        height: 16px;
        background: #ccc;
        margin: 0 4px;
      }
    </style>
  </head>
  <body>
    <nav class="harness-nav">
      <a href="/">Bundled WC</a>
      <a href="/external.html">External WC</a>
      <span class="nav-divider"></span>
      <a href="/preact.html">Preact</a>
      <a href="/react.html">React</a>
      <span class="nav-divider"></span>
      <a href="/preact-bundled.html" class="active">Preact (Bundled)</a>
      <a href="/react-bundled.html">React (Bundled)</a>
    </nav>
    <header>
      <div class="header-title">
        <strong>@florasync/leaflet-geokit</strong>
        <span style="opacity: 0.6">preact bundled dev harness</span>
      </div>
      <form id="geocodeForm" class="geocoder" autocomplete="off">
        <label for="geocodeQuery" class="sr-only">Search address</label>
        <input
          type="search"
          id="geocodeQuery"
          name="geocodeQuery"
          placeholder="Search address"
          required
        />
        <button type="submit" class="btn">Search</button>
      </form>
      <label
        style="
          display: flex;
          align-items: center;
          gap: 6px;
          font-size: 12px;
          opacity: 0.85;
        "
      >
        <input type="checkbox" id="replaceMode" />
        Replace existing layers
      </label>
      <div
        id="geocodeStatus"
        class="geocode-status"
        role="status"
        aria-live="polite"
      ></div>
    </header>
    <div class="wrap">
      <div id="map-container"></div>

      <div class="panel">
        <div class="row">
          <button class="btn" id="btnGet">getGeoJSON()</button>
          <button class="btn secondary" id="btnClear">clearLayers()</button>
          <button class="btn secondary" id="btnLoad">loadGeoJSON(demo)</button>
          <button
            class="btn secondary"
            id="btnUpload"
            title="Upload GeoJSON (Ctrl/Cmd+O)"
          >
            Upload GeoJSON…
          </button>
          <input
            type="file"
            id="fileInput"
            accept=".geojson,.json,application/geo+json,application/json"
            style="display: none"
          />
          <button
            class="btn"
            id="btnExport"
            title="Export GeoJSON (Ctrl/Cmd+S)"
          >
            Export GeoJSON
          </button>
          <button
            class="btn secondary"
            id="btnMergePolygons"
            title="Merge all visible polygons into one"
          >
            Merge Polygons
          </button>
        </div>
        <div class="row">
          <code>Events</code>
          <span id="evtTag" style="opacity: 0.7">…</span>
        </div>
        <pre id="out">{}</pre>
      </div>
    </div>

    <!-- Component (bundled Leaflet) -->
    <script type="module">
      import "/src/index.ts";
      import { h, render } from "https://esm.sh/preact@10.25.4";

      let mapElement = null;

      // Simple Preact wrapper that renders the web component
      function MapApp() {
        return h("leaflet-geokit", {
          ref: (el) => {
            if (el) setupMap(el);
          },
          style: { display: "block", height: "100%", width: "100%" },
          latitude: "39.7392",
          longitude: "-104.9903",
          zoom: "11",
          "tile-url": "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          "draw-polygon": true,
          "draw-polyline": true,
          "draw-rectangle": true,
          "draw-circle": true,
          "draw-layer-cake": true,
          "draw-marker": true,
          "draw-ruler": true,
          "edit-features": true,
          "delete-features": true,
          "log-level": "debug",
        });
      }

      render(h(MapApp), document.getElementById("map-container"));

      function setupMap(el) {
        mapElement = el;
        setupMapEventListeners(el);
      }

      function getMap() {
        return mapElement;
      }

      const waitForMapReady = () =>
        mapElement
          ? Promise.resolve()
          : new Promise((resolve) => {
              const check = () => {
                if (mapElement) resolve();
                else setTimeout(check, 50);
              };
              check();
            });

      // UI handlers
      const geocodeForm = document.getElementById("geocodeForm");
      const geocodeInput = document.getElementById("geocodeQuery");
      const geocodeStatus = document.getElementById("geocodeStatus");
      const replaceToggle = document.getElementById("replaceMode");
      const geocodeButton = geocodeForm?.querySelector('button[type="submit"]');

      function setGeocodeStatus(message, isError = false) {
        if (!geocodeStatus) return;
        geocodeStatus.textContent = message;
        geocodeStatus.style.color = isError ? "#b00020" : "#555";
      }

      function log(obj) {
        const out = document.getElementById("out");
        out.textContent = JSON.stringify(obj, null, 2);
        console.log(obj);
      }

      function showToast(message, type = "info", opts = {}) {
        const { title, timeout = 4000 } = opts;
        let container = document.getElementById("toasts");
        if (!container) {
          container = document.createElement("div");
          container.id = "toasts";
          container.className = "toast-container";
          container.setAttribute("role", "region");
          container.setAttribute("aria-live", "polite");
          document.body.appendChild(container);
        }
        const t = document.createElement("div");
        t.className = `toast ${type}`;
        t.setAttribute("role", type === "error" ? "alert" : "status");
        t.innerHTML = `${title ? `<div class="toast-title">${title}</div>` : ""}<div class="toast-message"></div>`;
        t.querySelector(".toast-message").textContent = message;
        container.appendChild(t);
        requestAnimationFrame(() => t.classList.add("show"));
        const remove = () => {
          t.classList.remove("show");
          setTimeout(() => t.remove(), 200);
        };
        if (timeout > 0) setTimeout(remove, timeout);
        t.addEventListener("click", remove);
        return remove;
      }

      function tag(msg) {
        document.getElementById("evtTag").textContent = msg;
      }

      function setupMapEventListeners(map) {
        map.addEventListener("leaflet-draw:ready", (e) => {
          tag("ready");
          log({ event: "ready", detail: e.detail });
        });
        map.addEventListener("leaflet-draw:created", (e) => {
          tag("created");
          log({ event: "created", detail: e.detail });
        });
        map.addEventListener("leaflet-draw:edited", (e) => {
          tag("edited");
          log({ event: "edited", detail: e.detail });
        });
        map.addEventListener("leaflet-draw:deleted", (e) => {
          tag("deleted");
          log({ event: "deleted", detail: e.detail });
        });
        map.addEventListener("leaflet-draw:export", (e) => {
          const { geoJSON, featureCount } = e.detail || {};
          try {
            const text = JSON.stringify(geoJSON, null, 2);
            const blob = new Blob([text], { type: "application/geo+json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            const ts = new Date();
            const pad = (n) => String(n).padStart(2, "0");
            const stamp = `${ts.getFullYear()}${pad(ts.getMonth() + 1)}${pad(ts.getDate())}-${pad(ts.getHours())}${pad(ts.getMinutes())}${pad(ts.getSeconds())}`;
            a.href = url;
            a.download = `leaflet-draw-export-${stamp}.geojson`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            showToast(`Exported ${featureCount ?? 0} feature(s)`, "success");
            log({ event: "export", featureCount, file: a.download });
          } catch (err) {
            console.error(err);
            showToast("Export failed", "error");
          }
        });
        map.addEventListener("leaflet-draw:ingest", (e) => {
          try {
            const incoming = e.detail?.fc;
            if (!incoming || incoming.type !== "FeatureCollection") return;
            e.detail.fc = flattenMultiGeometries(incoming);
          } catch (err) {
            console.warn("ingest flatten failed", err);
          }
        });
      }

      function flattenMultiGeometries(fc) {
        const out = [];
        for (const f of fc.features || []) {
          if (!f || f.type !== "Feature" || !f.geometry) continue;
          const base = f.properties || {};
          const g = f.geometry;
          switch (g.type) {
            case "MultiPolygon":
              for (const poly of g.coordinates) {
                out.push({
                  type: "Feature",
                  properties: { ...base },
                  geometry: { type: "Polygon", coordinates: poly },
                });
              }
              break;
            case "MultiLineString":
              for (const line of g.coordinates) {
                out.push({
                  type: "Feature",
                  properties: { ...base },
                  geometry: { type: "LineString", coordinates: line },
                });
              }
              break;
            case "MultiPoint":
              for (const pt of g.coordinates) {
                out.push({
                  type: "Feature",
                  properties: { ...base },
                  geometry: { type: "Point", coordinates: pt },
                });
              }
              break;
            case "GeometryCollection":
              for (const child of g.geometries || []) {
                out.push({
                  type: "Feature",
                  properties: { ...base },
                  geometry: child,
                });
              }
              break;
            default:
              out.push(f);
          }
        }
        return { type: "FeatureCollection", features: out };
      }

      // Geocode
      if (geocodeForm && geocodeInput) {
        geocodeForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          const query = geocodeInput.value.trim();
          if (!query) {
            setGeocodeStatus("Enter a search term");
            return;
          }
          setGeocodeStatus("Searching…");
          geocodeButton?.setAttribute("disabled", "disabled");
          try {
            await waitForMapReady();
            const map = getMap();
            const params = new URLSearchParams({
              format: "jsonv2",
              q: query,
              addressdetails: "1",
              limit: "1",
              polygon_geojson: "1",
            });
            const response = await fetch(
              `https://nominatim.openstreetmap.org/search?${params.toString()}`,
              { headers: { Accept: "application/json" } },
            );
            if (!response.ok)
              throw new Error(`Geocoder request failed: ${response.status}`);
            const results = await response.json();
            if (!Array.isArray(results) || results.length === 0) {
              setGeocodeStatus("No results found");
              showToast("No results found", "info");
              return;
            }
            const match = results[0];
            const replace = !!(replaceToggle && replaceToggle.checked);
            const bb =
              Array.isArray(match.boundingbox) && match.boundingbox.length === 4
                ? match.boundingbox.map(Number)
                : null;
            if (bb && bb.every(Number.isFinite)) {
              const [south, north, west, east] = bb;
              await map.fitBounds(
                [
                  [south, west],
                  [north, east],
                ],
                0.05,
              );
            } else {
              const lat = Number(match.lat);
              const lon = Number(match.lon);
              if (Number.isFinite(lat) && Number.isFinite(lon))
                await map.setView(lat, lon);
            }
            if (match.geojson && typeof match.geojson === "object") {
              const featureCollection = {
                type: "FeatureCollection",
                features: [
                  {
                    type: "Feature",
                    properties: {
                      source: "nominatim",
                      display_name: match.display_name,
                      class: match.class,
                      type: match.type,
                    },
                    geometry: match.geojson,
                  },
                ],
              };
              try {
                if (replace) {
                  await map.loadGeoJSON(featureCollection);
                  await map.fitBoundsToData(0.05);
                } else {
                  await map.addFeatures(featureCollection);
                }
              } catch (err) {
                console.warn(
                  "Failed to add GeoJSON geometry from geocoder",
                  err,
                );
              }
            }
            tag("geocode");
            log({ event: "geocode", query, result: match });
            setGeocodeStatus(match.display_name ?? "Moved to location");
          } catch (error) {
            console.error(error);
            setGeocodeStatus("Search failed", true);
            showToast("Search failed", "error");
          } finally {
            geocodeButton?.removeAttribute("disabled");
          }
        });
      }

      // Buttons
      document.getElementById("btnGet").addEventListener("click", async () => {
        await waitForMapReady();
        const fc = await getMap().getGeoJSON();
        log({ method: "getGeoJSON", featureCount: fc.features.length, fc });
      });
      document
        .getElementById("btnClear")
        .addEventListener("click", async () => {
          await waitForMapReady();
          await getMap().clearLayers();
          log({ method: "clearLayers", ok: true });
        });
      document.getElementById("btnLoad").addEventListener("click", async () => {
        await waitForMapReady();
        const demo = {
          type: "FeatureCollection",
          features: [
            {
              type: "Feature",
              properties: { name: "Demo Point" },
              geometry: { type: "Point", coordinates: [-104.9903, 39.7392] },
            },
          ],
        };
        const replace = !!(replaceToggle && replaceToggle.checked);
        if (replace) {
          await getMap().loadGeoJSON(demo);
          await getMap().fitBoundsToData(0.05);
        } else {
          await getMap().addFeatures(demo);
        }
        log({
          method: "loadGeoJSON",
          loaded: true,
          featureCount: demo.features.length,
        });
      });
      const fileInput = document.getElementById("fileInput");
      const btnUpload = document.getElementById("btnUpload");
      if (btnUpload && fileInput) {
        btnUpload.addEventListener("click", () => fileInput.click());
        fileInput.addEventListener("change", async (e) => {
          const file = e.target?.files?.[0];
          if (!file) return;
          try {
            setGeocodeStatus(`Reading ${file.name}…`);
            const text = await file.text();
            let json;
            try {
              json = JSON.parse(text);
            } catch {
              setGeocodeStatus("Invalid JSON in file", true);
              showToast("Invalid JSON in file", "error");
              return;
            }
            const fc =
              json.type === "FeatureCollection"
                ? json
                : json.type === "Feature"
                  ? { type: "FeatureCollection", features: [json] }
                  : null;
            if (!fc) {
              setGeocodeStatus("Not a valid GeoJSON file", true);
              showToast("Not a valid GeoJSON file", "error");
              return;
            }
            await waitForMapReady();
            const map = getMap();
            const replace = !!(replaceToggle && replaceToggle.checked);
            if (replace) {
              await map.loadGeoJSON(fc);
              await map.fitBoundsToData(0.05);
            } else {
              await map.addFeatures(fc);
              await map.fitBoundsToData(0.05);
            }
            setGeocodeStatus(
              `Loaded ${fc.features.length} feature(s) from ${file.name}`,
            );
            showToast(`Loaded ${fc.features.length} feature(s)`, "success");
            log({
              event: "upload",
              file: file.name,
              featureCount: fc.features.length,
            });
          } catch (err) {
            console.error(err);
            setGeocodeStatus("Upload failed", true);
            showToast("Upload failed", "error");
          } finally {
            fileInput.value = "";
          }
        });
      }
      const btnExport = document.getElementById("btnExport");
      if (btnExport) {
        btnExport.addEventListener("click", async () => {
          try {
            await waitForMapReady();
            await getMap().exportGeoJSON();
          } catch (err) {
            console.error(err);
            showToast("Export failed", "error");
          }
        });
      }
      const btnMergePolygons = document.getElementById("btnMergePolygons");
      if (btnMergePolygons) {
        btnMergePolygons.addEventListener("click", async () => {
          try {
            await waitForMapReady();
            const map = getMap();
            const beforeFC = await map.getGeoJSON();
            const beforeCount = beforeFC.features.length;
            if (beforeCount <= 1) {
              showToast("Need at least 2 polygon layers to merge", "info");
              return;
            }
            const newId = await map.mergePolygons({
              properties: {
                merged: true,
                source: "merged-features",
                timestamp: new Date().toISOString(),
              },
            });
            if (newId) {
              const afterFC = await map.getGeoJSON();
              const mergedCount = beforeCount - afterFC.features.length + 1;
              tag("merged");
              showToast(`Merged ${mergedCount} polygon layers`, "success", {
                title: "Polygons Merged",
              });
              log({
                method: "mergePolygons",
                beforeCount,
                afterCount: afterFC.features.length,
                mergedCount,
                mergedFeatureId: newId,
              });
            } else {
              showToast("No polygon layers were found to merge", "info");
            }
          } catch (err) {
            console.error(err);
            showToast("Failed to merge polygons", "error");
          }
        });
      }
      window.addEventListener("keydown", async (e) => {
        const mod = e.metaKey || e.ctrlKey;
        if (!mod || e.shiftKey || e.altKey) return;
        const k = (e.key || "").toLowerCase();
        if (k === "s") {
          e.preventDefault();
          try {
            await waitForMapReady();
            await getMap().exportGeoJSON();
          } catch (err) {
            showToast("Export failed", "error");
          }
        } else if (k === "o") {
          e.preventDefault();
          if (fileInput && "click" in fileInput) fileInput.click();
        }
      });
    </script>
    <div
      id="toasts"
      class="toast-container"
      role="region"
      aria-live="polite"
      aria-atomic="true"
    ></div>
  </body>
</html>
